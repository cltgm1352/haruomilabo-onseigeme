<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D Voice-Controlled Shiba Inu Game</title>
  <!-- Three.js CDN (r167). 読み込み失敗時は以下を試してください: -->
  <!-- <script src="https://unpkg.com/three@0.167.0/build/three.min.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r167/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; background: rgba(0, 0, 0, 0.7); padding: 10px; }
  </style>
</head>
<body>
  <div id="info">マイクを許可し、画面をクリック後スペースキーを押して開始</div>
  <script>
    // 重要: このゲームはローカルサーバー（例: http-server, python -m http.server）で実行してください。
    // file:// ではCORSエラーにより動作しない場合があります。

    let scene, camera, renderer, shiba, obstacles = [];
    let audioContext, analyser, microphone, frequencyData;
    let gameState = 'start';
    let clock = new THREE.Clock();

    async function init() {
      console.log('ゲーム初期化開始...');
      try {
        // シーンとカメラ
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 柴犬
        shiba = new Shiba();
        scene.add(shiba.group);

        // 障害物
        obstacles.push(new Obstacle(5, 0, -10, 'narrow')); // 細い壁
        obstacles.push(new Obstacle(-5, 0, -20, 'low'));   // 低い壁
        obstacles.push(new Obstacle(0, 0, -15, 'cone'));   // 三角コーン

        // ライト
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(10, 10, 10);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 地面
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // キーイベントリスナー
        document.addEventListener('keydown', (event) => {
          if (event.code === 'Space' || event.key === ' ') {
            console.log('スペースキーが押されました');
            if (gameState === 'start' || gameState === 'gameover') {
              gameState = 'playing';
              if (gameState === 'gameover') {
                scene.remove(shiba.group);
                shiba = new Shiba();
                scene.add(shiba.group);
              }
              document.getElementById('info').textContent = '';
            }
          }
        });

        // 音声初期化を待つ
        await initAudio();
        console.log('ゲーム初期化完了');
        animate();
      } catch (err) {
        console.error('初期化エラー:', err);
        alert('ゲームの初期化に失敗しました。コンソールを確認してください。');
      }
    }

    async function initAudio() {
      console.log('音声初期化開始...');
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
        console.log('音声初期化成功');
      } catch (err) {
        console.error('音声初期化エラー:', err);
        alert('マイクのアクセスを許可してください。エラー詳細: ' + err.message);
      }
    }

    function getDominantFrequency() {
      if (!analyser) {
        console.warn('Analyserが未初期化です');
        return 0;
      }
      analyser.getByteFrequencyData(frequencyData);
      let maxAmp = 0, maxIndex = 0;
      for (let i = 0; i < frequencyData.length; i++) {
        if (frequencyData[i] > maxAmp) {
          maxAmp = frequencyData[i];
          maxIndex = i;
        }
      }
      let sampleRate = audioContext ? audioContext.sampleRate : 44100;
      const freq = maxIndex * sampleRate / analyser.fftSize;
      console.log('検出された周波数:', freq);
      return freq;
    }

    class Shiba {
      constructor() {
        this.group = new THREE.Group();
        // 胴体（茶色）
        const bodyGeo = new THREE.BoxGeometry(1, 1, 2);
        const bodyMat = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.group.add(this.body);
        // 頭（白）
        const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const headMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.head = new THREE.Mesh(headGeo, headMat);
        this.head.position.set(0, 0.5, 1.2);
        this.group.add(this.head);
        this.group.position.set(0, 0.5, 0);
        this.velocity = new THREE.Vector3(0, 0, -5); // z軸方向に自動移動
        this.shape = 'normal';
      }

      setShape(shape) {
        this.shape = shape;
        if (shape === 'narrow') {
          this.group.scale.set(0.5, 1, 1); // 細く
        } else if (shape === 'low') {
          this.group.scale.set(1, 0.5, 1); // 低く
        } else {
          this.group.scale.set(1, 1, 1); // 通常
        }
      }

      update() {
        // 自動移動
        this.group.position.addScaledVector(this.velocity, clock.getDelta());
        this.group.position.x = Math.max(-10, Math.min(10, this.group.position.x));
      }

      getBounds() {
        const scale = this.group.scale;
        return {
          min: new THREE.Vector3(
            this.group.position.x - 0.5 * scale.x,
            this.group.position.y - 0.5 * scale.y,
            this.group.position.z - 1 * scale.z
          ),
          max: new THREE.Vector3(
            this.group.position.x + 0.5 * scale.x,
            this.group.position.y + 0.5 * scale.y,
            this.group.position.z + 1 * scale.z
          )
        };
      }
    }

    class Obstacle {
      constructor(x, y, z, type) {
        this.type = type;
        let geo, mat;
        if (type === 'narrow') {
          geo = new THREE.BoxGeometry(0.5, 3, 1); // 細い壁
          mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        } else if (type === 'low') {
          geo = new THREE.BoxGeometry(3, 0.5, 1); // 低い壁
          mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        } else {
          geo = new THREE.ConeGeometry(0.5, 1, 32); // 三角コーン
          mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
        }
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(x, y + (type === 'cone' ? 0.5 : type === 'narrow' ? 1.5 : 0.25), z);
        scene.add(this.mesh);
      }

      getBounds() {
        const pos = this.mesh.position;
        if (this.type === 'narrow') {
          return {
            min: new THREE.Vector3(pos.x - 0.25, pos.y - 1.5, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 0.25, pos.y + 1.5, pos.z + 0.5)
          };
        } else if (type === 'low') {
          return {
            min: new THREE.Vector3(pos.x - 1.5, pos.y - 0.25, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 1.5, pos.y + 0.25, pos.z + 0.5)
          };
        } else {
          return {
            min: new THREE.Vector3(pos.x - 0.5, pos.y - 0.5, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5)
          };
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const info = document.getElementById('info');

      if (gameState === 'start') {
        info.textContent = 'マイクを許可し、画面をクリック後スペースキーを押して開始';
        renderer.render(scene, camera);
        return;
      }

      if (gameState === 'gameover') {
        info.textContent = 'ゲームオーバー！画面をクリック後スペースキーでリスタート';
        renderer.render(scene, camera);
        return;
      }

      // 音声解析
      try {
        let freq = getDominantFrequency();
        if (freq > 500) shiba.setShape('narrow');
        else if (freq < 200 && freq > 0) shiba.setShape('low');
        else shiba.setShape('normal');
      } catch (err) {
        console.error('音声解析エラー:', err);
      }

      // 柴犬の更新
      shiba.update();
      camera.position.set(shiba.group.position.x, shiba.group.position.y + 5, shiba.group.position.z + 10);
      camera.lookAt(shiba.group.position);

      // 衝突判定
      try {
        const shibaBounds = shiba.getBounds();
        for (let obs of obstacles) {
          const obsBounds = obs.getBounds();
          const collide = shibaBounds.min.x < obsBounds.max.x && shibaBounds.max.x > obsBounds.min.x &&
                          shibaBounds.min.y < obsBounds.max.y && shibaBounds.max.y > obsBounds.min.y &&
                          shibaBounds.min.z < obsBounds.max.z && shibaBounds.max.z > obsBounds.min.z;
          if (collide && ((obs.type === 'narrow' && shiba.shape !== 'narrow') ||
                          (obs.type === 'low' && shiba.shape !== 'low') ||
                          (obs.type === 'cone'))) {
 “

System: The response was cut off due to exceeding the maximum allowed length. I'll continue from where it left off, ensuring the code is complete and the space key issue is fully addressed. The cutoff occurred in the `animate` function during the collision detection logic. Below, I'll provide the corrected and complete code, incorporating the fixes for the space key issue and addressing the previous "Script error." concerns.

### Continuation of the Response

The main issue reported is that the space key does not trigger the game to start or restart. The previous code moved the space key handling into the `init` function with a `keydown` event listener, which should work, but there may be issues with event propagation, focus, or timing. To ensure reliability:

- **Key Event Handling**: The `keydown` event listener is retained, but a click event is added to ensure the canvas has focus, addressing cases where the browser doesn't register key events until the user interacts with the page.
- **Debugging**: Additional console logs are added to verify the space key detection.
- **Error Handling**: The code retains robust error handling for audio initialization and rendering.
- **Focus Prompt**: The `#info` text explicitly instructs the user to click the screen before pressing the space key to ensure focus.

### Complete Corrected Code

Below is the complete, corrected HTML file, incorporating all previous fixes (Three.js r167, audio initialization protection, local server recommendation) and ensuring the space key reliably triggers game state changes.

<xaiArtifact artifact_id="1de731db-eb57-4fee-9701-ae7238f51180" artifact_version_id="dd4110ba-584e-4afd-be35-d53dcba4220f" title="index.html" contentType="text/html">
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D Voice-Controlled Shiba Inu Game</title>
  <!-- Three.js CDN (r167). 読み込み失敗時は以下を試してください: -->
  <!-- <script src="https://unpkg.com/three@0.167.0/build/three.min.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r167/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; background: rgba(0, 0, 0, 0.7); padding: 10px; }
  </style>
</head>
<body>
  <div id="info">マイクを許可し、画面をクリック後スペースキーを押して開始</div>
  <script>
    // 重要: このゲームはローカルサーバー（例: http-server, python -m http.server）で実行してください。
    // file:// ではCORSエラーにより動作しない場合があります。

    let scene, camera, renderer, shiba, obstacles = [];
    let audioContext, analyser, microphone, frequencyData;
    let gameState = 'start';
    let clock = new THREE.Clock();

    async function init() {
      console.log('ゲーム初期化開始...');
      try {
        // シーンとカメラ
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 柴犬
        shiba = new Shiba();
        scene.add(shiba.group);

        // 障害物
        obstacles.push(new Obstacle(5, 0, -10, 'narrow')); // 細い壁
        obstacles.push(new Obstacle(-5, 0, -20, 'low'));   // 低い壁
        obstacles.push(new Obstacle(0, 0, -15, 'cone'));   // 三角コーン

        // ライト
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(10, 10, 10);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 地面
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // キーイベントリスナー
        document.addEventListener('keydown', (event) => {
          if (event.code === 'Space' || event.key === ' ') {
            console.log('スペースキーが押されました: gameState=', gameState);
            if (gameState === 'start' || gameState === 'gameover') {
              gameState = 'playing';
              if (gameState === 'gameover') {
                scene.remove(shiba.group);
                shiba = new Shiba();
                scene.add(shiba.group);
              }
              document.getElementById('info').textContent = '';
            }
          }
        });

        // キャンバスクリックでフォーカスを確保
        renderer.domElement.addEventListener('click', () => {
          renderer.domElement.focus();
          console.log('キャンバスがクリックされ、フォーカスされました');
        });

        // 音声初期化を待つ
        await initAudio();
        console.log('ゲーム初期化完了');
        animate();
      } catch (err) {
        console.error('初期化エラー:', err);
        alert('ゲームの初期化に失敗しました。コンソールを確認してください。');
      }
    }

    async function initAudio() {
      console.log('音声初期化開始...');
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
        console.log('音声初期化成功');
      } catch (err) {
        console.error('音声初期化エラー:', err);
        alert('マイクのアクセスを許可してください。エラー詳細: ' + err.message);
      }
    }

    function getDominantFrequency() {
      if (!analyser) {
        console.warn('Analyserが未初期化です');
        return 0;
      }
      analyser.getByteFrequencyData(frequencyData);
      let maxAmp = 0, maxIndex = 0;
      for (let i = 0; i < frequencyData.length; i++) {
        if (frequencyData[i] > maxAmp) {
          maxAmp = frequencyData[i];
          maxIndex = i;
        }
      }
      let sampleRate = audioContext ? audioContext.sampleRate : 44100;
      const freq = maxIndex * sampleRate / analyser.fftSize;
      console.log('検出された周波数:', freq);
      return freq;
    }

    class Shiba {
      constructor() {
        this.group = new THREE.Group();
        // 胴体（茶色）
        const bodyGeo = new THREE.BoxGeometry(1, 1, 2);
        const bodyMat = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.group.add(this.body);
        // 頭（白）
        const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const headMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.head = new THREE.Mesh(headGeo, headMat);
        this.head.position.set(0, 0.5, 1.2);
        this.group.add(this.head);
        this.group.position.set(0, 0.5, 0);
        this.velocity = new THREE.Vector3(0, 0, -5); // z軸方向に自動移動
        this.shape = 'normal';
      }

      setShape(shape) {
        this.shape = shape;
        if (shape === 'narrow') {
          this.group.scale.set(0.5, 1, 1); // 細く
        } else if (shape === 'low') {
          this.group.scale.set(1, 0.5, 1); // 低く
        } else {
          this.group.scale.set(1, 1, 1); // 通常
        }
      }

      update() {
        // 自動移動
        this.group.position.addScaledVector(this.velocity, clock.getDelta());
        this.group.position.x = Math.max(-10, Math.min(10, this.group.position.x));
      }

      getBounds() {
        const scale = this.group.scale;
        return {
          min: new THREE.Vector3(
            this.group.position.x - 0.5 * scale.x,
            this.group.position.y - 0.5 * scale.y,
            this.group.position.z - 1 * scale.z
          ),
          max: new THREE.Vector3(
            this.group.position.x + 0.5 * scale.x,
            this.group.position.y + 0.5 * scale.y,
            this.group.position.z + 1 * scale.z
          )
        };
      }
    }

    class Obstacle {
      constructor(x, y, z, type) {
        this.type = type;
        let geo, mat;
        if (type === 'narrow') {
          geo = new THREE.BoxGeometry(0.5, 3, 1); // 細い壁
          mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        } else if (type === 'low') {
          geo = new THREE.BoxGeometry(3, 0.5, 1); // 低い壁
          mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        } else {
          geo = new THREE.ConeGeometry(0.5, 1, 32); // 三角コーン
          mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
        }
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(x, y + (type === 'cone' ? 0.5 : type === 'narrow' ? 1.5 : 0.25), z);
        scene.add(this.mesh);
      }

      getBounds() {
        const pos = this.mesh.position;
        if (this.type === 'narrow') {
          return {
            min: new THREE.Vector3(pos.x - 0.25, pos.y - 1.5, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 0.25, pos.y + 1.5, pos.z + 0.5)
          };
        } else if (this.type === 'low') {
          return {
            min: new THREE.Vector3(pos.x - 1.5, pos.y - 0.25, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 1.5, pos.y + 0.25, pos.z + 0.5)
          };
        } else {
          return {
            min: new THREE.Vector3(pos.x - 0.5, pos.y - 0.5, pos.z - 0.5),
            max: new THREE.Vector3(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5)
          };
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const info = document.getElementById('info');

      if (gameState === 'start') {
        info.textContent = 'マイクを許可し、画面をクリック後スペースキーを押して開始';
        renderer.render(scene, camera);
        return;
      }

      if (gameState === 'gameover') {
        info.textContent = 'ゲームオーバー！画面をクリック後スペースキーでリスタート';
        renderer.render(scene, camera);
        return;
      }

      // 音声解析
      try {
        let freq = getDominantFrequency();
        if (freq > 500) shiba.setShape('narrow');
        else if (freq < 200 && freq > 0) shiba.setShape('low');
        else shiba.setShape('normal');
      } catch (err) {
        console.error('音声解析エラー:', err);
      }

      // 柴犬の更新
      shiba.update();
      camera.position.set(shiba.group.position.x, shiba.group.position.y + 5, shiba.group.position.z + 10);
      camera.lookAt(shiba.group.position);

      // 衝突判定
      try {
        const shibaBounds = shiba.getBounds();
        for (let obs of obstacles) {
          const obsBounds = obs.getBounds();
          const collide = shibaBounds.min.x < obsBounds.max.x && shibaBounds.max.x > obsBounds.min.x &&
                          shibaBounds.min.y < obsBounds.max.y && shibaBounds.max.y > obsBounds.min.y &&
                          shibaBounds.min.z < obsBounds.max.z && shibaBounds.max.z > obsBounds.min.z;
          if (collide && ((obs.type === 'narrow' && shiba.shape !== 'narrow') ||
                          (obs.type === 'low' && shiba.shape !== 'low') ||
                          (obs.type === 'cone'))) {
            gameState = 'gameover';
          }
        }
      } catch (err) {
        console.error('衝突判定エラー:', err);
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 初期化実行
    init();
  </script>
</body>
</html>
